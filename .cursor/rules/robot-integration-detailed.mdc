---
description: Robot integration and SSH communication patterns
---

# Robot Integration - Mercator Robots (RVR + Raspberry Pi)

## Arquitectura de Robots Mercator

### Hardware Components
- **Sphero RVR**: Robot base con orugas diferenciales
- **Raspberry Pi 4**: Computadora embebida (8GB RAM)
- **Sensores**: Color del suelo, IMU, LEDs RGB, transceptores IR
- **Sensores Adicionales**: Proximidad IR, LIDAR (opcional)
- **Sistema Operativo**: Ubuntu 20.04 LTS + ROS Noetic

### Software Architecture
- **Driver ROS**: C++ (acceso restringido a administradores)
- **Control Software**: Python (desarrollado por usuarios)
- **Comunicación**: SSH + ROS topics
- **Aislamiento**: Docker + cgroups para código de usuario

## Flujo de Comunicación

### 1. Despliegue de Scripts
```python
# Flujo de despliegue seguro
1. Usuario sube script Python vía Frontend
2. Backend valida y almacena script
3. Celery task ejecuta despliegue SSH
4. Paramiko transfiere script vía SCP
5. Script ejecutado en contenedor aislado
6. Resultados enviados vía WebSockets
```

### 2. Telemetría en Tiempo Real
```python
# Flujo de telemetría
1. Robot publica datos ROS (20-30 Hz)
2. Foxglove Bridge consume topics
3. Backend retransmite vía WebSockets
4. Frontend visualiza en tiempo real
```

## Servicios de Integración

### SSH Service
- **Autenticación**: SSH keys (sin contraseña)
- **Transferencia**: SCP/SFTP para archivos
- **Ejecución**: Comandos remotos seguros
- **Monitoreo**: Estado de conexión

### ROS Integration
- **Topics**: /rvr/odom, /rvr/imu, /rvr/cmd_vel
- **Services**: /rvr/reset, /rvr/calibrate
- **Parameters**: Configuración del robot
- **Namespaces**: Aislamiento por usuario

### Tycho Integration
- **Seguimiento**: Cámaras cenitales + ArUco
- **Filtros**: Kalman para estimación de pose
- **Métricas**: Eficiencia del enjambre
- **Visualización**: Mapa de trayectorias

## Seguridad y Aislamiento

### Docker Sandboxing
```dockerfile
# Contenedor para código de usuario
FROM python:3.8-slim
RUN apt-get update && apt-get install -y \
    ros-noetic-desktop \
    && rm -rf /var/lib/apt/lists/*
COPY requirements.txt .
RUN pip install -r requirements.txt
```

### Resource Limits
```yaml
# Límites de recursos
cgroups:
  cpu: "0.5"        # 50% CPU
  memory: "512m"     # 512MB RAM
  ulimit:
    -t: 300         # 5 minutos CPU
    -u: 100         # 100 procesos
```

### ROS Namespace Isolation
```python
# Aislamiento por usuario
/user_A/cmd_vel    # Comandos del usuario A
/user_B/cmd_vel    # Comandos del usuario B
/global/odom       # Odometría global
/global/imu        # IMU global
```

## Patrones de Desarrollo

### SSH Communication
```python
# Ejemplo de comunicación SSH
import paramiko

def deploy_script(robot_host, script_content):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(robot_host, username='sphero', key_filename='id_rsa')
    
    # Transferir script
    sftp = ssh.open_sftp()
    sftp.put(script_content, '/tmp/user_script.py')
    
    # Ejecutar en contenedor
    cmd = "docker run --rm -v /tmp:/workspace python:3.8 python /workspace/user_script.py"
    stdin, stdout, stderr = ssh.exec_command(cmd)
    
    return stdout.read().decode()
```

### ROS Integration
```python
# Ejemplo de integración ROS
import rospy
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry

class RobotController:
    def __init__(self, namespace):
        rospy.init_node(f'user_controller_{namespace}')
        self.cmd_pub = rospy.Publisher(f'/{namespace}/cmd_vel', Twist, queue_size=1)
        self.odom_sub = rospy.Subscriber('/global/odom', Odometry, self.odom_callback)
    
    def move_robot(self, linear_x, angular_z):
        twist = Twist()
        twist.linear.x = linear_x
        twist.angular.z = angular_z
        self.cmd_pub.publish(twist)
```

### Error Handling
```python
# Manejo de errores robusto
try:
    result = deploy_script(robot_host, script_content)
except paramiko.AuthenticationException:
    logger.error("SSH authentication failed")
except paramiko.SSHException as e:
    logger.error(f"SSH error: {e}")
except Exception as e:
    logger.error(f"Unexpected error: {e}")
finally:
    ssh.close()
```

## Monitoreo y Observabilidad

### Métricas de Robot
- **Estado de conexión**: SSH + ROS
- **Uso de recursos**: CPU, RAM, disco
- **Latencia de comunicación**: SSH + ROS
- **Errores de ejecución**: Logs + excepciones

### Alertas
- **Robot desconectado**: SSH timeout
- **Recursos excedidos**: cgroups limits
- **Errores de ROS**: Topic failures
- **Scripts maliciosos**: Anomaly detection